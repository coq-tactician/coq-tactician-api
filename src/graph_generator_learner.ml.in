open Tactician_ltac1_record_plugin
open Tactic_learner
open Names
open Graph_extractor
open Graph_def

module OList = CList

let dirpath = Global.current_dirpath ()

module GlobalCICGraph(S : Set.S) = struct
  include GlobalGraph(S)(
    struct
      type edge_label = edge_type
      type node_label = (S.elt * (bool * int)) node_type
      let is_definition = function
        | Definition _ -> true
        | _ -> false
    end)
  let lower n = n, Int64.of_int 0
  let lift (n, _) = n
  let transform_node_type n = n, Int64.of_int 0
end

module rec GlobalHashedCICGraph : functor (S : Set.S) -> sig
  type node' = GlobalHashedCICGraph(S).node
  type nonrec builder = (S.t, node' node_type * int64, edge_type, S.elt * (bool * inv_rel_key)) builder
  include GraphMonadType
    with type node_label = node' node_type
     and type edge_label = edge_type
     and type 'a repr_t = builder -> S.elt -> 'a * builder
  val lower : node -> (S.elt * (bool * int)) * int64
  val lift : (S.elt * (bool * int)) * int64 -> node
  val builder_nil : builder
  val transform_node_type : 'a -> 'a
end = functor (S : Set.S) -> struct
  type node' = GlobalHashedCICGraph(S).node
  module GG = GlobalGraph(S)(
    struct
      type edge_label = edge_type
      type node_label = node' node_type * int64
      let is_definition (d, _) = match d with
        | Definition _ -> true
        | _ -> false
    end)
  type builder = GG.builder
  let builder_nil = GG.builder_nil
  include GraphHasher
      (struct
        type node_label = GlobalHashedCICGraph(S).node node_type
        type edge_label = edge_type
      end)
      (CICHasher(XXHasher))(GG)
  let transform_node_type n = n
end

(* module G = GlobalCICGraph(DPset) *)
module G = GlobalHashedCICGraph(DPset)
module CICGraphMonad = struct
  include CICGraphMonad(G)
  type node' = node
end
module GB = GraphBuilder(CICGraphMonad)

module GraphGeneratorLearner : TacticianOnlineLearnerType = functor (TS : TacticianStructures) -> struct
  module LH = Learner_helper.L(TS)
  open TS

  type model = (((proof_state * term * proof_state list) list * tactic option) list * data_status * KerName.t) list

  let last_model = Summary.ref ~name:"dataset-generator-learner-lastmodel" []

  let cache_type kn =
    let dirp = Global.current_dirpath () in
    let kn_dirp =
      let rec get_dirpath = function
        | MPfile dp -> dp
        | MPbound b ->
          let (_, id, dp) = MBId.repr b in
          dp
        | MPdot (mp, l) -> get_dirpath mp in
      get_dirpath @@ KerName.modpath kn in
    if DirPath.equal dirp kn_dirp then `File else `Dependency

  let empty () = []
  let learn db (kn, path, status) outcomes tac =
    match cache_type kn, status with
    | `File, (QedTime | Discharged _ | Substituted _)  ->
      let proof_states = List.map (fun x -> x.before, x.term, List.rev x.after) outcomes in
      let db = match db with
        | (ls, pstatus, pkn)::data when KerName.equal kn pkn ->
          ((proof_states, tac)::ls, pstatus, pkn)::data
        | _ -> ([proof_states, tac], status, kn)::db in
      last_model := db;
      db
    | (`Dependency, _) | (`File, Original) -> db
  let predict db situations = IStream.empty
  let evaluate db _ _ = 0., db

  type glob_ref2 =
    | GConstant of constant
    | GInductive of inductive
    | GConstructor of constructor
    | GProjection of Projection.Repr.t

  open CICGraphMonad

  (* Global state of the graph generator *)
  let graph_builder = ref G.builder_nil
  let definition_nodes = ref Int.Set.empty
  let dependencies = Summary.ref ~name:"TacticianGraphDependencies" DPmap.empty
  let section_nodes = Summary.ref ~name:"TacticianGraphSectionNodes" Id.Map.empty
  let global_nodes = Summary.ref ~name:"TacticianGraphGlobalNodes"
      { constants = Cmap.empty
      ; inductives = Indmap.empty
      ; constructors = Constrmap.empty
      ; projections = ProjMap.empty }
  let previous_definition = Summary.ref ~name:"TacticianGraphPreviousDefinition" None
  let external_previous_definitions = Summary.ref ~name:"TacticianGraphExternalPreviousDefinition" DPmap.empty
  let known_external_previous_definitions =
    Summary.ref ~name:"TacticianGraphKnownExternalPreviousDefinition" DPmap.empty

  let update_error p ns n = function
    | None -> Some (ns, n)
    | Some ((NActual, _) as x) ->
      (match ns with
       | NSubstituted ->
         (* This is valid and can happen when the substitution of a constant is a null-op. We want to ignore these. *)
         Some x
       | _ ->
         CErrors.anomaly Pp.(str "Map update attempt while key already existed: " ++ p))
    | Some ((NDischarged | NSubstituted), _) -> Some (ns, n)
  let in_global_nodes : node_status * glob_ref2 -> Libobject.obj =
    Libobject.(declare_object @@ superglobal_object "LTACRECORDGRAPHNODES"
                 ~cache:(fun ((fp, kn), ((ns, n), gr)) ->
                     let gn = !global_nodes in
                     global_nodes := match gr with
                       | GConstant c ->
                         { gn with constants = Cmap.update c (update_error (Constant.print c) ns n) gn.constants }
                       | GInductive i ->
                         { gn with inductives = Indmap.update i (update_error (Pp.str "ind") ns n) gn.inductives }
                       | GConstructor c ->
                         { gn with constructors = Constrmap.update c (update_error (Pp.str "constr") ns n) gn.constructors }
                       | GProjection p ->
                         { gn with projections = ProjMap.update p (update_error (Pp.str "proj") ns n) gn.projections }
                   )
                 ~subst:(Some (fun (o, ((_, n), gr)) ->
                     (NSubstituted, n), match gr with
                     | GConstant c ->
                       GConstant (Mod_subst.subst_constant o c)
                     | GInductive i -> GInductive (Mod_subst.subst_ind o i)
                     | GConstructor (i, n) -> GConstructor (Mod_subst.subst_ind o i, n)
                     | GProjection p -> GProjection (Mod_subst.subst_proj_repr o p)
                   ))
                 ~discharge:(fun (_, ((_, n), gr)) -> Some ((NDischarged, n), gr)))
  let in_dependencies : (DirPath.t * string * DPset.t) -> Libobject.obj =
    Libobject.(declare_object @@ superglobal_object_nodischarge "LTACRECORDGRAPHDEPS"
        ~cache:(fun (_, (path, bin, deps)) -> dependencies := DPmap.add path (bin, deps) !dependencies)
        ~subst:None)
  let in_previous_definition : node option -> Libobject.obj =
    Libobject.(declare_object @@ superglobal_object_nodischarge "LTACRECORDGRAPHPREVIOUS"
                 ~cache:(fun (_, prev) ->
                     match prev with
                     | None -> ()
                     | Some prev ->
                       let ((d, n), _) = G.lower prev in
                       if DirPath.equal d dirpath then
                         previous_definition := Some prev
                       else
                         external_previous_definitions := DPmap.add d prev !external_previous_definitions)
                 ~subst:(Some (fun (_, _) -> None)))
  let in_known_external_previous_definition : node option -> Libobject.obj =
    Libobject.(declare_object @@ superglobal_object_nodischarge "LTACRECORDGRAPHKNOWNEXTERNAL"
                 ~cache:(fun (_, prev) ->
                     match prev with
                     | None -> ()
                     | Some prev ->
                       let ((d, n), _) = G.lower prev in
                       known_external_previous_definitions := DPmap.add d prev !known_external_previous_definitions)
                 ~subst:(Some (fun (_, _) -> None)))

  open GB

  let proof_state_to_pair ps =
    let concl = proof_state_goal ps in
    let hyps = proof_state_hypotheses ps in
    proof_state_sigma ps, (), (List.map (map_named term_repr) hyps, term_repr concl, proof_state_evar ps)

  let grandfathered_constants =
    [ match Coqlib.lib_ref "tactician.private_constant_placeholder" with
      | Names.GlobRef.ConstRef const -> const
      | _ -> assert false
    ]

  let update_graph () =
    let err_msg c = Pp.(str "Unexpected definition" ++ ws 1 ++ c ++ ws 1 ++ str "encountered. " ++
                        str "Did you forget to inject Tactician while installing a dependency?") in
    let globrefs = Environ.Globals.view (Global.env ()).env_globals in
    let section_vars = Id.Set.of_list @@
      List.map Context.Named.Declaration.get_id @@ Environ.named_context @@ Global.env () in
    let constants = Cmap_env.filter
        (fun c _ ->
           (not @@ List.exists (Constant.CanOrd.equal c) grandfathered_constants) &&
           match Cmap.find_opt c !global_nodes.constants with
           | Some (NActual, _) -> false
           | None | Some ((NSubstituted | NDischarged), _) -> true
        ) globrefs.constants in
    (* We are only interested in canonical constants *)
    let constants = Cmap_env.fold (fun c _ m ->
        let c = Constant.make1 @@ Constant.canonical c in
        if not @@ DirPath.equal dirpath @@ ModPath.dp @@ Constant.modpath c then
          CErrors.user_err (err_msg (Constant.print c));
        Cset.add c m) constants Cset.empty in
    let minductives = Mindmap_env.filter
        (fun m _ ->
           match Indmap.find_opt (m, 0) !global_nodes.inductives with
           | Some (NActual, _) -> false
           | None | Some ((NSubstituted | NDischarged), _) -> true) globrefs.inductives in
    (* We are only interested in canonical inductives *)
    let minductives = Mindmap_env.fold (fun c _ m ->
        let c = MutInd.make1 @@ MutInd.canonical c in
        if not @@ DirPath.equal dirpath @@ ModPath.dp @@ MutInd.modpath c then
          CErrors.user_err (err_msg (MutInd.print c));
        Mindset.add c m) minductives Mindset.empty in
    let open Monad_util.WithMonadNotations(CICGraphMonad) in
    let open Monad.Make(CICGraphMonad) in

    let proof_states = OList.map (fun (prf, status, c) -> OList.rev prf, status, c) @@ OList.rev !last_model in

    (* Correctness check *)
    let lemmas = OList.filter_map (function (_, Discharged _, _) -> None | (_, _, x) -> Some x) proof_states in
    let global_context =
      KNset.elements @@ Cmap_env.fold (fun c _ m ->
        let c = Constant.canonical c in
        KNset.add c m) globrefs.constants KNset.empty in
    let lemmas = OList.filter (fun x ->
        (not @@ OList.exists (KerName.equal x) global_context) &&
        (not @@ Id.Set.mem (Label.to_id @@ KerName.label x) section_vars)
      ) lemmas in
    OList.iter (fun x ->
        let base = Label.to_id @@ KerName.label x in
        let candidates = OList.filter (fun x -> Names.Id.equal (Label.to_id @@ KerName.label x) base ) global_context in
        Feedback.msg_warning Pp.(str "Unknown lemma: " ++ KerName.print x ++ str "\nAlternatives:\n" ++
                            prlist_with_sep (fun () -> str "\n") KerName.print candidates)) lemmas;
    (* End correctness check *)

    let env = Global.env () in
    let env_extra_const = Cset.fold (fun c m ->
        let path = Constant.canonical c in
        let proof = OList.find_opt (fun (p, _, path2) -> KerName.equal path path2) proof_states in
        let proof = Option.map (fun (p, _, _) -> p) proof in
        let proof = Option.map (OList.map (fun (pss, tac) ->
            OList.map (fun (b, term, ass) ->
                proof_state_to_pair b, term_repr term, OList.map proof_state_to_pair ass) pss,
            Option.map tactic_repr tac)) proof in
        Option.fold_left (fun m proof -> Cmap.add c proof m) m proof
      ) constants Cmap.empty in
    let env_extra_var = Id.Set.fold (fun id m ->
        let proof = OList.find_opt (fun (_, _, path) -> Id.equal id @@ Label.to_id @@ KerName.label path) proof_states in
        let proof = Option.map (fun (p, _, _) -> p) proof in
        let proof = Option.map (OList.map (fun (pss, tac) ->
            OList.map (fun (b, term, ass) ->
                proof_state_to_pair b, term_repr term, OList.map proof_state_to_pair ass) pss,
            Option.map tactic_repr tac)) proof in
        Option.fold_left (fun m proof -> Id.Map.add id proof m) m proof
      ) section_vars Id.Map.empty in
    let env_extra = env_extra_var, env_extra_const in

    (* We calculate a topological ordering of the definitions, in order to create a layout with more reference of
       locality in the graph encoding. This is not needed for correctness, it's an optimization only. *)
    let defs = Definition_order.order env section_vars constants minductives in
    let updater =
      List.iter (function
          | Definition_order.TConst c -> map (fun _ -> ()) @@ gen_const env env_extra c
          | Definition_order.TMutInd m -> gen_mutinductive_helper env env_extra m
          | Definition_order.TVar id -> map (fun _ -> ()) @@ gen_section_var env env_extra id) defs
    in
    let known = DPmap.domain !known_external_previous_definitions in
    let external_previous = OList.map snd @@ DPmap.bindings @@
      DPmap.filter (fun p _ -> not @@ DPset.mem p known) !external_previous_definitions in
    let (new_state, ()), builder =
      CICGraphMonad.run ~include_metadata:true ~state:{ previous = !previous_definition
                          ; external_previous
                          ; section_nodes = !section_nodes
                          ; definition_nodes = !global_nodes }
        updater !graph_builder (Global.current_dirpath ()) in
    graph_builder := builder;
    section_nodes := new_state.section_nodes;
    definition_nodes := Id.Map.fold (fun _ n s ->
        let ((path, (def, n)), _) = G.lower n in
        if not @@ DirPath.equal path dirpath then CErrors.anomaly Pp.(str "Local node expected");
        assert def;
        Int.Set.add n s) new_state.section_nodes !definition_nodes;
    definition_nodes := Cmap.fold (fun _  (_status, n) s ->
        let ((path, (def, n)), _) = G.lower n in
        assert def;
        if DirPath.equal path dirpath then Int.Set.add n s else s)
        new_state.definition_nodes.constants !definition_nodes;
    definition_nodes := Indmap.fold (fun _ (_status, n) s ->
        let ((path, (def, n)), _) = G.lower n in
        assert def;
        if DirPath.equal path dirpath then Int.Set.add n s else s)
        new_state.definition_nodes.inductives !definition_nodes;
    definition_nodes := Constrmap.fold (fun _ (_status, n) s ->
        let ((path, (def, n)), _) = G.lower n in
        assert def;
        if DirPath.equal path dirpath then Int.Set.add n s else s)
        new_state.definition_nodes.constructors !definition_nodes;
    definition_nodes := ProjMap.fold (fun _ (_status, n) s ->
        let ((path, (def, n)), _) = G.lower n in
        assert def;
        if DirPath.equal path dirpath then Int.Set.add n s else s)
        new_state.definition_nodes.projections !definition_nodes;

    let new_known = DPmap.filter
        (fun p _ ->
           (not @@ DPset.mem p known) &&
           (not @@ OList.exists (fun n ->
                let ((p', _), _) = G.lower n in
                DirPath.equal p p') new_state.external_previous))
        !external_previous_definitions in
    DPmap.iter (fun _ n -> Lib.add_anonymous_leaf @@ in_known_external_previous_definition (Some n)) new_known;

    Lib.add_anonymous_leaf @@ in_previous_definition new_state.previous;

    let update_definitions iter find defs wrap check =
      iter
        (fun c (ns, n) ->
           match ns with
           | NDischarged | NSubstituted -> ()
           | NActual ->
             match find c with
             | None ->
               check c;
               Lib.add_anonymous_leaf @@ in_global_nodes ((NActual, n), wrap c)
             | Some (NActual, _) -> ()
             | Some ((NDischarged | NSubstituted), _) ->
               Lib.add_anonymous_leaf @@ in_global_nodes ((NActual, n), wrap c)
        ) defs in
    update_definitions Cmap.iter (fun c -> Cmap.find_opt c !global_nodes.constants)
      new_state.definition_nodes.constants (fun c -> GConstant c)
      (fun c ->
         if (not @@ CList.exists (Constant.CanOrd.equal c) grandfathered_constants) &&
            (not @@ Cset.mem c constants) then
           CErrors.user_err (err_msg @@ Constant.print c));
    update_definitions Indmap.iter (fun i -> Indmap.find_opt i !global_nodes.inductives)
      new_state.definition_nodes.inductives (fun i -> GInductive i)
      (fun i ->
         if not @@ Mindset.mem (fst i) minductives then
           CErrors.user_err (err_msg @@  MutInd.print (fst i)));
    update_definitions Constrmap.iter (fun c -> Constrmap.find_opt c !global_nodes.constructors)
      new_state.definition_nodes.constructors (fun c -> GConstructor c)
      (fun c ->
         if not @@ Mindset.mem (fst (fst c)) minductives then
           CErrors.user_err (err_msg @@  MutInd.print (fst (fst c))));
    update_definitions ProjMap.iter (fun p -> ProjMap.find_opt p !global_nodes.projections)
      new_state.definition_nodes.projections (fun p -> GProjection p)
      (fun p ->
         if not @@ Mindset.mem (Projection.Repr.mind p) minductives then
           CErrors.user_err (err_msg @@  MutInd.print (Projection.Repr.mind p)))

  let source = ref @@ Tactician_util.try_locate_absolute_library dirpath
  let data_file () = match !source with
    | None -> CErrors.anomaly Pp.(str "Source file location could not be found")
    | Some f -> Filename.remove_extension f ^ ".bin"
  let () = Hook.set Stm.document_add_hook (fun CAst.{ loc; _ } _ ->
      (* TODO: This does not work because of the '-load-vernac' flag; commands from a loaded file
         will have their original location attached, which is wrong for our purposes. This manifests
         itself when compiling an empty file. *)
      (* (match loc with *)
      (*  | None -> () *)
      (*  | Some Loc.{ fname = ToplevelInput; _ } -> source := None *)
      (*  | Some Loc.{ fname = InFile f; _ } -> source := Some f); *)
      update_graph ())

  let resolve_dependencies deps =
    let absolute_deps = List.map (fun p ->
        match DPmap.find_opt p !dependencies with
        | None -> CErrors.anomaly (Pp.str ("Dependency was not resolvable: " ^ DirPath.to_string p))
        | Some (f, _) -> f
      ) deps in
    let pwd = Sys.getcwd () in
    (match Sys.getenv_opt "OPAM_PACKAGE_NAME" with
     | None -> ()
     | Some _ ->
       let (/) = Filename.concat in
       let prefix = "%{prefix}%" in
       let build_dir = prefix/".opam-switch"/"build" in
       match CString.is_sub build_dir pwd 0 with
       | false -> ()
       | true -> Sys.chdir build_dir);
    let relative_deps = List.map (fun f ->
        let f = CUnix.strip_path f in
        if not @@ Filename.is_relative f then
          Feedback.msg_warning
            Pp.(str "Dependency could not be relativized w.r.t. a common root. " ++
                str "An absolute path was inserted into the dataset: " ++ str f);
        f
      ) absolute_deps in
    Sys.chdir pwd;
    relative_deps

  module K = Graph_api.Make(Capnp.BytesMessage)
  let write_graph { paths; def_count; node_count; edge_count; defs; nodes; edges }
      definition_nodes representative =
    let depslist = dirpath :: DPset.elements (DPset.remove dirpath paths) in
    let path_index = CList.fold_left_i (fun i map path -> DPmap.add path i map) 0 DPmap.empty depslist in
    let resolved_dependencies = resolve_dependencies depslist in
    let g = K.Builder.Dataset.init_root () in
    let _ = K.Builder.Dataset.dependencies_set_list g resolved_dependencies in
    (match representative with
     | None ->
       K.Builder.Dataset.representative_set_int_exn g (def_count + node_count)
     | Some representative ->
       let ((rp, (def, representative)), _) = G.lower representative in
       assert def;
       if not (DirPath.equal rp dirpath) then
         CErrors.anomaly Pp.(str "Representative is not from the current file: " ++ DirPath.print rp);
       K.Builder.Dataset.representative_set_int_exn g representative);
    let _ = K.Builder.Dataset.definitions_set_list g @@
      List.map (fun n -> Stdint.Uint32.of_int @@ n) @@ Int.Set.elements definition_nodes in
    let path_transform (p, _) =
      DPmap.find p path_index in
    let node_local_index (_, (def, i)) =
      if def then i else def_count + i in
    let node_hash n = snd n in
    let node_label n = fst @@ G.transform_node_type n in
    let capnp_graph = K.Builder.Dataset.graph_init g in
    Graph_capnp_generator.write_graph ~include_metadata:true
      ~node_hash ~node_label ~node_lower:(fun n -> fst @@ G.lower n)
      ~node_dep_index:path_transform ~node_local_index
      ~node_count:(def_count + node_count) ~edge_count (AList.append defs nodes) edges capnp_graph;
    Capnp_unix.IO.write_message_to_file ~compression:`None (K.Builder.Dataset.to_message g) (data_file ())

  let () = Declaremods.append_end_library_hook @@ fun () ->
    print_endline "writing";
    update_graph ();

    (* We want the dependencies of the graph to contain any non-transitive imports *)
    let second_level_deps = DPmap.fold (fun _ (_, s') s -> DPset.union s s') !dependencies DPset.empty in
    let non_trans_deps = DPset.filter (fun d -> not @@ DPset.mem d second_level_deps) @@ DPmap.domain !dependencies in
    let graph_builder = !graph_builder in
    let graph_builder = { graph_builder with paths = DPset.union graph_builder.paths non_trans_deps } in

    Lib.add_anonymous_leaf @@ in_dependencies (dirpath, (data_file ()), DPmap.domain !dependencies);
    write_graph graph_builder !definition_nodes !previous_definition

end

(* let () = register_online_learner "Dataset Generator Learner" (module GraphGeneratorLearner) *)
(* let () = Tactic_learner_internal.disable_queue () *)
