open Tactician_ltac1_record_plugin
open Tactic_learner
open Names
open Graph_extractor
open Graph_capnp_generator
open Graph_def

module OList = CList

let dirpath = Global.current_dirpath ()
let data_file () = match Tactician_util.base_filename with
  | None -> CErrors.anomaly Pp.(str "Source file location could not be found")
  | Some f -> f ^ ".bin"

module G = GlobalGraph(DPset)(struct type result = graph_state end)
module CICGraph = struct
  type node' = DirPath.t * int
  include CICGraphMonad(G)
end
module GB = GraphBuilder(CICGraph)
module CapnpGraphWriter = CapnpGraphWriter(struct type path = DirPath.t end)(G)

module GraphGeneratorLearner : TacticianOnlineLearnerType = functor (TS : TacticianStructures) -> struct
  module LH = Learner_helper.L(TS)
  open TS

  type model = ((proof_state list * tactic) list * Libnames.full_path) list

  let last_model = Summary.ref ~name:"dataset-generator-learner-lastmodel" []

  type glob_ref2 =
    | GConstant of constant
    | GInductive of inductive
    | GConstructor of constructor
    | GProjection of Projection.Repr.t

  open CICGraph
  let global_nodes = Summary.ref ~name:"TacticianGraphGlobalNodes"
      { constants = Cmap.empty
      ; inductives = Indmap.empty
      ; constructors = Constrmap.empty
      ; projections = ProjMap.empty }

  let update_error x = function
    | None -> Some x
    | Some _ -> CErrors.anomaly (Pp.str "Map update attempt while key already existed")
  let in_global_nodes : node * glob_ref2 -> Libobject.obj =
    Libobject.(declare_object @@ superglobal_object "LTACRECORDGRAPHNODES"
                 ~cache:(fun (_, (n, gr)) ->
                     let gn = !global_nodes in
                     global_nodes := match gr with
                       | GConstant c -> { gn with constants = Cmap.update c (update_error n) gn.constants }
                       | GInductive i -> { gn with inductives = Indmap.update i (update_error n) gn.inductives }
                       | GConstructor c ->
                         { gn with constructors = Constrmap.update c (update_error n) gn.constructors }
                       | GProjection p -> { gn with projections = ProjMap.update p (update_error n) gn.projections }
                   )
                 ~subst:None
                 ~discharge:(fun x -> Some (snd x)))

  let dependencies = Summary.ref ~name:"TacticianGraphDependencies" DPmap.empty
  let in_dependencies : (DirPath.t * string) -> Libobject.obj =
    Libobject.(declare_object @@ superglobal_object "LTACRECORDGRAPHDEPS"
        ~cache:(fun (_, (path, bin)) -> dependencies := DPmap.add path bin !dependencies)
        ~subst:None
        ~discharge:(fun x -> Some (snd x)))

  let cache_type name =
    let dirp = Global.current_dirpath () in
    if Libnames.is_dirpath_prefix_of dirp (Libnames.dirpath name) then `File else `Dependency

  let empty () = []
  let learn db (path, _status) outcomes tac =
    match cache_type path with
    | `File ->
      let proof_states = List.map (fun x -> x.before) outcomes in
      let db = match db with
        | (ls, ppath)::data when Libnames.eq_full_path path ppath ->
          ((proof_states, tac)::ls, ppath)::data
        | _ -> ([proof_states, tac], path)::db in
      last_model := db; db
    | `Dependency -> db
  let predict db situations = IStream.empty
  let evaluate db _ _ = 0., db

  let resolve_dependencies deps =
    let absolute_deps = List.map (fun p ->
        match DPmap.find_opt p !dependencies with
        | None -> CErrors.anomaly (Pp.str ("Dependency was not resolvable: " ^ DirPath.to_string p))
        | Some f -> f
      ) deps in
    let pwd = Sys.getcwd () in
    (match Sys.getenv_opt "OPAM_PACKAGE_NAME" with
     | None -> ()
     | Some _ ->
       let (/) = Filename.concat in
       let prefix = "%{prefix}%" in
       let build_dir = prefix/".opam-switch"/"build" in
       match CString.is_sub build_dir pwd 0 with
       | false -> ()
       | true -> Sys.chdir build_dir);
    let relative_deps = List.map (fun f ->
        let f = CUnix.strip_path f in
        if not @@ Filename.is_relative f then
          Feedback.msg_warning
            Pp.(str "Dependency could not be relativized w.r.t. a common root. " ++
                str "An absolute path was inserted into the dataset: " ++ str f);
        f
      ) absolute_deps in
    Sys.chdir pwd;
    relative_deps

  open GB

  let proof_state_to_pair ps =
    let concl = proof_state_goal ps in
    let hyps = proof_state_hypotheses ps in
    (List.map (map_named term_repr) hyps, term_repr concl)

  let graph_builder = ref G.builder_nil
  let tactical_constants = ref []

  let update_graph () =
    let err_msg c = Pp.(str "Unexpected definition" ++ ws 1 ++ c ++ ws 1 ++ str "encountered. " ++
                        str "Did you forget to install a dependency without Tactician injected?") in
    let globrefs = Environ.Globals.view (Global.env ()).env_globals in
    let constants = Cmap_env.filter
        (fun c _ -> not @@ Cmap.mem c !global_nodes.constants) globrefs.constants in
    (* We are only interested in canonical constants *)
    let constants = Cset.elements @@ Cmap_env.fold (fun c _ m ->
        let c = Constant.make1 @@ Constant.canonical c in
        if not @@ DirPath.equal dirpath @@ ModPath.dp @@ Constant.modpath c then
          CErrors.user_err (err_msg (Constant.print c));
        Cset.add c m) constants Cset.empty in
    let minductives = Mindmap_env.filter
        (fun m _ -> not @@ Indmap.mem (m, 0) !global_nodes.inductives) globrefs.inductives in
    (* We are only interested in canonical inductives *)
    let minductives = Mindset.elements @@ Mindmap_env.fold (fun c _ m ->
        let c = MutInd.make1 @@ MutInd.canonical c in
        if not @@ DirPath.equal dirpath @@ ModPath.dp @@ MutInd.modpath c then
          CErrors.user_err (err_msg (MutInd.print c));
        Mindset.add c m) minductives Mindset.empty in
    let open Monad_util.WithMonadNotations(CICGraph) in
    let open Monad.Make(CICGraph) in

    let proof_states = OList.rev !last_model in
    let proof_states = OList.map (fun (prf, c) -> OList.rev prf, c) proof_states in

    (* Correctness check *)
    let lemmas = OList.map snd proof_states in
    let context_lemmas = OList.map (fun x -> Nametab.path_of_global (Names.GlobRef.ConstRef x)) constants in
    let lemmas = OList.filter (fun x -> not @@ OList.exists (fun y -> Libnames.eq_full_path x y ) context_lemmas) lemmas in
    OList.iter (fun x ->
        let base = Libnames.basename x in
        let candidates = OList.filter (fun x -> Names.Id.equal (Libnames.basename x) base ) context_lemmas in
        CErrors.user_err Pp.(str "Unknown lemma: " ++ Libnames.pr_path x ++ str "\nAlternatives:\n" ++
                                 prlist_with_sep (fun () -> str "\n") Libnames.pr_path candidates)) lemmas;
    (* End correctness check *)

    let env = Global.env () in
    let env_extra = OList.fold_left (fun m c ->
        let path = Nametab.path_of_global (Names.GlobRef.ConstRef c) in
        let proof = OList.find_opt (fun (p, path2) -> Libnames.eq_full_path path path2) proof_states in
        let proof = Option.map fst proof in
        let proof = Option.map (OList.map (fun (pss, tac) ->
            OList.map proof_state_to_pair pss, tactic_repr tac)) proof in
        Option.fold_left (fun m proof -> Cmap.add c proof m) m proof
      ) Cmap.empty constants in

    let updater =
      let+ cnodes = List.map (fun c ->
          let+ n = gen_const env env_extra c in
        c, n) constants
      and+ () = List.iter (gen_mutinductive_helper env env_extra) minductives in
      cnodes in
    let (known_definitions, constant_nodes), builder =
      CICGraph.run ~known_definitions:!global_nodes updater !graph_builder (Global.current_dirpath ()) in
    graph_builder := builder;
    let tactical_constants' = OList.filter_map (fun (c, n) ->
        match Cmap.mem c env_extra with
        | true -> Some n
        | false -> None) constant_nodes in
    tactical_constants := tactical_constants' @ !tactical_constants;

    Cmap.iter
      (fun c n -> if not @@ Cmap.mem c !global_nodes.constants then begin
          if not @@ CList.exists (Constant.CanOrd.equal c) constants then
            CErrors.user_err (err_msg @@ Constant.print c);
          Lib.add_anonymous_leaf @@ in_global_nodes (n, GConstant c)
        end) known_definitions.constants;
    Indmap.iter
      (fun i n -> if not @@ Indmap.mem i !global_nodes.inductives then begin
           if not @@ CList.exists (MutInd.CanOrd.equal (fst i)) minductives then
             CErrors.user_err (err_msg @@  MutInd.print (fst i));
           Lib.add_anonymous_leaf @@ in_global_nodes (n, GInductive i)
         end) known_definitions.inductives;
    Constrmap.iter
    (fun c n -> if not @@ Constrmap.mem c !global_nodes.constructors then begin
        if not @@ CList.exists (MutInd.CanOrd.equal (fst (fst c))) minductives then
          CErrors.user_err (err_msg @@  MutInd.print (fst (fst c)));
        Lib.add_anonymous_leaf @@ in_global_nodes (n, GConstructor c)
      end) known_definitions.constructors;
    ProjMap.iter
      (fun p n -> if not @@ ProjMap.mem p !global_nodes.projections then begin
           if not @@ CList.exists (MutInd.CanOrd.equal (Projection.Repr.mind p)) minductives then
             CErrors.user_err (err_msg @@  MutInd.print (Projection.Repr.mind p));
           Lib.add_anonymous_leaf @@ in_global_nodes (n, GProjection p)
         end) known_definitions.projections

  module K = Graph_api.Make(Capnp.BytesMessage)
  let write_graph G.{ paths; node_count; edge_count; builder } tactical_constants =
    let depslist = dirpath :: DPset.elements (DPset.remove dirpath paths) in
    let path_index = CList.fold_left_i (fun i map path -> DPmap.add path i map) 0 DPmap.empty depslist in
    let resolved_dependencies = resolve_dependencies depslist in
    let g = K.Builder.Dataset.init_root () in
    let _ = K.Builder.Dataset.dependencies_set_list g resolved_dependencies in
    let _ = K.Builder.Dataset.tactical_definitions_set_list g @@
      List.map (fun n -> Stdint.Uint32.of_int @@ snd n) tactical_constants in
    let transformer tp =
      DPmap.find tp path_index in
    let capnp_graph = K.Builder.Dataset.graph_init g in
    CapnpGraphWriter.write_graph capnp_graph transformer node_count edge_count builder;
    Capnp_unix.IO.write_message_to_file ~compression:`Packing (K.Builder.Dataset.to_message g) (data_file ())

  let () = Declaremods.append_end_library_hook @@ fun () ->
    print_endline "writing";
    update_graph ();
    Lib.add_anonymous_leaf @@ in_dependencies (dirpath, (data_file ()));
    write_graph !graph_builder !tactical_constants

end

(* let () = register_online_learner "Dataset Generator Learner" (module GraphGeneratorLearner) *)
(* let () = Tactic_learner_internal.disable_queue () *)
